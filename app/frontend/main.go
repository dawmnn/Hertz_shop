// Code generated by hertz generator.

package main

import (
	"context"
	"github.com/cloudwego/biz-demo/gomall/app/frontend/biz/router"
	"github.com/cloudwego/biz-demo/gomall/app/frontend/conf"
	"github.com/cloudwego/biz-demo/gomall/app/frontend/infra/rpc"
	"github.com/cloudwego/biz-demo/gomall/app/frontend/middleware"
	frontendUtils "github.com/cloudwego/biz-demo/gomall/app/frontend/utils"
	"github.com/cloudwego/biz-demo/gomall/common/mtl"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/hertz-contrib/cors"
	"github.com/hertz-contrib/gzip"
	"github.com/hertz-contrib/logger/accesslog"
	hertzlogrus "github.com/hertz-contrib/logger/logrus"
	prometheus "github.com/hertz-contrib/monitor-prometheus"
	hertzobslogrus "github.com/hertz-contrib/obs-opentelemetry/logging/logrus"
	hertztracing "github.com/hertz-contrib/obs-opentelemetry/tracing"
	"github.com/hertz-contrib/pprof"
	"github.com/hertz-contrib/sessions"
	"github.com/hertz-contrib/sessions/redis"
	"github.com/joho/godotenv"
	"go.uber.org/zap/zapcore"
	"gopkg.in/natefinch/lumberjack.v2"
	"os"
	"time"
)

var (
	ServiceName  = frontendUtils.ServiceName
	RegistryAddr = conf.GetConf().Hertz.RegistryAddr
	MetricsPort  = conf.GetConf().Hertz.MetricsPort
)

func main() {
	_ = godotenv.Load()
	consul, registerInfo := mtl.InitMetric(ServiceName, MetricsPort, RegistryAddr)
	defer consul.Deregister(registerInfo)

	p := mtl.InitTracing(ServiceName)
	defer p.Shutdown(context.Background())
	// init dal
	// dal.Init()
	rpc.InitClient()
	address := conf.GetConf().Hertz.Address

	//hertztracing.NewServerTracer() 是一个函数，它初始化并返回两个值：
	//tracer: 这是一个追踪器实例，它会负责处理与追踪相关的操作（如启动、停止追踪等）。
	//cfg: 这是配置对象，可能包含一些追踪器的配置选项（比如日志、格式化等），用于后续配置或中间件使用。
	tracer, cfg := hertztracing.NewServerTracer()

	//server.WithTracer(...)：这项配置用于为服务器设置追踪器。在这行代码中，使用了 Prometheus 的追踪器：
	//prometheus.NewServerTracer("", "", prometheus.WithDisableServer(true),
	//prometheus.WithRegistry(mtl.Register))：
	//这是创建一个 Prometheus 追踪器的过程。该追踪器用于收集和导出服务的指标数据到 Prometheus 系统：
	//prometheus.WithDisableServer(true)：禁用 Prometheus 的服务器追踪。
	//prometheus.WithRegistry(mtl.Register)：指定 Prometheus 使用的注册表，
	//mtl.Register 可能是某个自定义的注册表，用于注册 Prometheus 指标。
	h := server.New(server.WithHostPorts(address),
		server.WithTracer(prometheus.NewServerTracer("", "",
			prometheus.WithDisableServer(true),
			prometheus.WithRegistry(mtl.Register),
		)),
		tracer,
		//tracer：这个值来自 hertztracing.NewServerTracer()，它是另一个追踪器，可
		//能与 Prometheus 追踪器一起使用，具体取决于后续的追踪配置。
	)

	h.Use(hertztracing.ServerMiddleware(cfg))
	//h.Use(hertztracing.ServerMiddleware(cfg)) 为 hertz 服务器添加了一个追踪中间件，
	//该中间件将确保每个请求在进入服务时都能被追踪，并记录相关的追踪信息（如请求 ID、执行时间等）。

	registerMiddleware(h)

	// add a ping route to test
	h.GET("/ping", func(c context.Context, ctx *app.RequestContext) {
		ctx.JSON(consts.StatusOK, utils.H{"ping": "pong"})
	})

	router.GeneratedRegister(h)
	h.LoadHTMLGlob("template/*")
	h.Static("/static", "./")
	h.GET("/about", middleware.Auth(), func(c context.Context, ctx *app.RequestContext) {
		hlog.CtxInfof(c, "CloudWeGo shop about page")
		//在给定的上下文 c 中记录一条 信息级别 的日志，日志内容为 "CloudWeGo shop about page"。
		ctx.HTML(consts.StatusOK, "about", utils.H{"Title": "About"})
	})
	//用于运行一个 Hertz 服务器，并且在接收到操作系统的关闭信号或者发生错误时进行处理。
	//它实现了一个优雅的关闭机制，确保服务器能够在关闭时完成必要的清理工作。
	h.GET("/sign-in", func(c context.Context, ctx *app.RequestContext) {
		data := utils.H{
			"Title": "Sign In",
			"Next":  ctx.Query("next"),
			//ctx.Request.Header.Get("Referer"),
		}
		ctx.HTML(consts.StatusOK, "sign-in", data)
	})
	//注册
	h.GET("/sign-up", func(c context.Context, ctx *app.RequestContext) {
		ctx.HTML(consts.StatusOK, "sign-up", utils.H{"Title": "Sign Up"})
	})

	h.Spin()
}

func registerMiddleware(h *server.Hertz) {
	store, _ := redis.NewStore(10, "tcp", conf.GetConf().Redis.Address, "",
		[]byte(os.Getenv("SESSION_SECRET")))
	h.Use(sessions.New("cloudwego-shop", store))

	// log
	logger := hertzobslogrus.NewLogger(hertzobslogrus.WithLogger(hertzlogrus.NewLogger().Logger()))
	//logger := hertzlogrus.NewLogger()
	hlog.SetLogger(logger)
	hlog.SetLevel(conf.LogLevel())
	//主线程在记录日志时，不会被等待或阻塞，它只需要将日志消息放入队列并继续执行，
	//不需要等到日志实际写入完毕。这样主程序的性能和响应速度不会受到日志写入的影响。
	//asyncWriter：创建了一个异步写入日志的 BufferedWriteSyncer，
	//使用 lumberjack 库来管理日志文件的滚动（即日志文件达到一定大小后会进行分割），
	//并且设置了日志文件的一些参数，如最大大小、备份数量和日志保留的最大天数。
	var flushInterval time.Duration
	if os.Getenv("GO_ENV") == "online" {
		flushInterval = time.Minute
	} else {
		flushInterval = time.Second
	}
	asyncWriter := &zapcore.BufferedWriteSyncer{
		WS: zapcore.AddSync(&lumberjack.Logger{
			Filename:   conf.GetConf().Hertz.LogFileName,
			MaxSize:    conf.GetConf().Hertz.LogMaxSize,
			MaxBackups: conf.GetConf().Hertz.LogMaxBackups,
			MaxAge:     conf.GetConf().Hertz.LogMaxAge,
		}),
		FlushInterval: flushInterval,
	}
	//将日志的输出设置为 asyncWriter，也就是说日志将被写入到文件中
	hlog.SetOutput(asyncWriter)
	//在服务器关闭时，调用 asyncWriter.Sync() 来确保日志缓冲区中的日志被及时写入文件。
	h.OnShutdown = append(h.OnShutdown, func(ctx context.Context) {
		asyncWriter.Sync()
	})

	//这部分代码用于启用性能分析（pprof）中间件。pprof 是 Go 自带的性能分析工具，
	//用于监控程序的运行状况（比如 CPU 使用情况、内存分配等）。
	//如果配置文件中启用了 EnablePprof，
	//则调用 pprof.Register(h) 将 pprof 注册到 Hertz 服务器中，允许通过某些端点来访问性能数据
	// pprof
	if conf.GetConf().Hertz.EnablePprof {
		pprof.Register(h)
	}

	//这段代码用于启用 Gzip 压缩功能。Gzip 是一种常用的压缩算法，用于减小 HTTP 响应的体积，提升传输效率。
	//如果配置文件中启用了 EnableGzip，
	//则会使用 gzip.Gzip(gzip.DefaultCompression) 中间件将服务器的响应数据进行 Gzip 压缩。
	// gzip
	if conf.GetConf().Hertz.EnableGzip {
		h.Use(gzip.Gzip(gzip.DefaultCompression))
	}

	//这段代码用于记录访问日志。每当有请求进入时，都会记录一条日志，通常包括请求的时间、URL、方法、状态码等信息。
	//如果配置文件中启用了 EnableAccessLog，则使用 accesslog.New() 创建并使用访问日志中间件。
	// access log
	if conf.GetConf().Hertz.EnableAccessLog {
		h.Use(accesslog.New())
	}

	//段代码启用了错误恢复中间件。当 HTTP 请求处理过程中发生 panic 时，
	//recovery.Recovery() 中间件可以捕获这个 panic，并且防止整个服务崩溃，
	//从而返回一个 500 错误响应给客户端。
	//h.Use(recovery.Recovery()) 将该中间件添加到 Hertz 服务器的中间件链中。
	// recovery
	h.Use(recovery.Recovery())

	//这部分代码启用了 CORS（跨域资源共享）中间件。
	//CORS 是一个允许或者限制不同域的客户端访问服务器资源的机制。
	//cors.Default() 表示使用默认的 CORS 设置，这样所有的域都可以访问该服务。
	// cores
	h.Use(cors.Default())
	middleware.Register(h)
}
